// Copyright (c) 2022 Slack Technologies, Inc.

#import <AppKit/AppKit.h>
#import <Foundation/Foundation.h>
#import "BorderPanelController.h"

#define BORDER_VIEW_BORDER_WIDTH	5
#define TIMER_INTERVAL_SEC		 	0.5

@interface BorderPanelController ()

@property (nonatomic, readwrite) pid_t processId;
@property (nonatomic, readwrite) NSInteger windowOrScreenNumber;
@property (nonatomic, readwrite) CGFloat borderWidth;
@property (nonatomic, readwrite) BOOL isScreen;
@property (nonatomic, readwrite) BOOL isHidden;
@property (nonatomic, strong, readwrite) NSMutableArray * visibleWindows;
@property (nonatomic, strong, readwrite) BorderPanel * borderPanel;
@property (nonatomic, strong, readwrite) NSColor * color;
@property (nonatomic, readwrite) BOOL debug;

@property (nonatomic,  readwrite) int currentX;
@property (nonatomic,  readwrite) int currentY;
@property (nonatomic,  readwrite) int currentWidth;
@property (nonatomic,  readwrite) int currentHeight;

@end

@implementation BorderPanelController

- (id) initWithWindowOrScreenNumber:(NSString *)windowOrScreenNumber {
	BorderPanel* borderPanel = [[BorderPanel alloc] initWithContentRect:NSZeroRect styleMask:0 backing:NSBackingStoreBuffered defer:false];
	[borderPanel setBackgroundColor:[NSColor clearColor]];

	[self updateWindowOrScreenNumber:windowOrScreenNumber];
	[self setBorderWidth:5.0];
	[self getVisibleWindows];
	[self setBorderPanel:borderPanel];
	[self addGlobalMonitorForEvents:[self windowOrScreenNumber]];
	[self show];

	// Set this to true when verbose logging is needed.
	[self setDebug:false];

	return self;
}

- (void) updateWindowOrScreenNumber:(NSString *)windowOrScreenNumber {
	if ([self debug]) {
		printf("Window or screen number = %s", [windowOrScreenNumber UTF8String]);
	}

	[self setIsScreen:[self isScreenNumber:windowOrScreenNumber]];
	[self setWindowOrScreenNumber:[self parseWindowOrScreenNumber:windowOrScreenNumber]];

	NSDictionary * windowInfo = [self getWindowByNumber:[self windowOrScreenNumber]];
	[self setProcessId:[self getWindowProcesssIdFromInfo:windowInfo]];

	[self updateFrame];
}

- (void) updateBorderWidth: (CGFloat)borderWidth {
	[self setBorderWidth:borderWidth];
	NSView * view = [[self borderPanel] contentView];
	[[view layer] setBorderWidth:borderWidth];
	[self updateFrame];
}

- (void) updateBackgroundColorWithRed: (CGFloat)red green:(CGFloat)green blue:(CGFloat)blue alpha:(CGFloat)alpha {
	NSColor * color = [NSColor colorWithRed:red green:green blue:blue alpha:alpha];
	NSView * view = [[self borderPanel] contentView];
	[[view layer] setBorderColor:[color CGColor]];
}

- (void) updateFrame {
	if ([self isHidden]) return;

	if ([self isScreen]) {
		NSArray<NSScreen *> * screens = [NSScreen screens];
		NSRect frame = NSZeroRect;
		for (NSUInteger i = 0; i < [screens count]; i++) {
			NSScreen * screen = screens[i];
			NSDictionary<NSDeviceDescriptionKey, id> *description = [screen deviceDescription];
			NSInteger screenId = [[description valueForKey:@"NSScreenNumber"] unsignedIntValue];

			if (screenId == [self windowOrScreenNumber]) {
				frame = [screen frame];
			}
		}

		[[self borderPanel] setCollectionBehavior:
		 NSWindowCollectionBehaviorCanJoinAllSpaces
		 | NSWindowCollectionBehaviorFullScreenAuxiliary /* use only for when in full screen mode */
		 | NSWindowCollectionBehaviorStationary];
		[[self borderPanel] setLevel:NSScreenSaverWindowLevel];

		[[self borderPanel] setFrame:frame display:true];
		[[self borderPanel] orderFront:nil];
	} else {
		NSDictionary * windowInfo = [self getWindowByNumber:[self windowOrScreenNumber]];
		NSRect frame = [self getWindowBoundsFromInfo:windowInfo];

		NSString * name = (NSString * )windowInfo[(id)kCGWindowOwnerName];

		// This shitty conversation is needed because
		// Core graphics origin is at top left and
		// Cocoa origin is at bottom left
		// https://stackoverflow.com/questions/20520902/how-to-get-nswindow-size-from-kcgwindownumber
		// And the [self borderWidth] is border width which should not overlap on the window
		int x = frame.origin.x - [self borderWidth];
		NSArray<NSScreen *> *screens = NSScreen.screens;
		int y = NSMaxY(screens[0].frame) - NSMaxY(frame) - [self borderWidth];
		frame.origin.x = x;
		frame.origin.y = y;
		frame.size.width = frame.size.width + (2 * [self borderWidth]);
		frame.size.height = frame.size.height + (2 * [self borderWidth]);

		[[self borderPanel] setCollectionBehavior:NSWindowCollectionBehaviorStationary];

		[[self borderPanel] setLevel:NSNormalWindowLevel];

		[[self borderPanel] setFrame:frame display:true];
		[[self borderPanel] orderWindow:NSWindowAbove relativeTo:[self getWindowNumberFromInfo:windowInfo]];

		if ([self debug]) {
			printf("BorderPanelController setFrame windowNumber = %ld, windowName = %s\n", [self windowOrScreenNumber], [name UTF8String]);
			printf("Frame (x, y) = (%f, %f), (width, height) = (%f, %f)\n", frame.origin.x, frame.origin.y, frame.size.width, frame.size.height);
		}
	}
}

- (void) show {
	[self setIsHidden:false];
	[self updateFrame];
}

- (void) hide {
	[self setIsHidden:true];
	[[self borderPanel] orderOut:nil];
}

- (int) getWindowXPosition {
	return [self currentX];
}

- (int) getWindowYPosition {
	return [self currentY];
}

- (int) getWindowWidth {
	return [self currentWidth];
}

- (int) getWindowHeight {
	return [self currentHeight];
}

- (void) addGlobalMonitorForEvents:(NSInteger)windowNumber {
	if ([self debug]) {
		printf("BorderPanelController addGlobalMonitorForEvents windowNumber = %ld\n", windowNumber);
	}

	[NSEvent addGlobalMonitorForEventsMatchingMask:NSEventMaskLeftMouseDown handler:^(NSEvent * event) {
		if ([self isScreen]) return;

		if ([event windowNumber] == [self windowOrScreenNumber]) {
			NSPoint point = [event locationInWindow];

			if ([self debug]) {
				printf("Global leftMouseDown location (x: %f, y: %f)\n", point.x, point.y);
			}

			[self updateFrame];
			return;
		}

		if ([self debug]) {
			printf("BorderPanelController addGlobalMonitorForEvents mouseDown for window = %ld\n", [event windowNumber]);
		}

		[NSTimer scheduledTimerWithTimeInterval:TIMER_INTERVAL_SEC repeats:false block:^(NSTimer *timer) {
			NSPoint point = [event locationInWindow];
			NSRunningApplication * application = [[NSWorkspace sharedWorkspace] frontmostApplication];

			if ([self debug]) {
				printf("Global leftMouseDown location (x: %f, y: %f)\n", point.x, point.y);
				printf("Front most application Pid = %d, self pid = %d\n", [application processIdentifier], [self processId]);
			}

			if ([application processIdentifier] == [self processId]) {
				[self updateFrame];
			} else if ([self debug]) {
				printf("Skipping update\n");
			}
		}];
	}];

	[NSEvent addGlobalMonitorForEventsMatchingMask:NSEventMaskLeftMouseDragged handler:^(NSEvent * event) {
		if ([self isScreen]) return;

		if ([event windowNumber] == [self windowOrScreenNumber]) {
				// NSPoint point = [event locationInWindow];
				// printf("Global leftMouseDragged location (x: %f, y: %f)\n", point.x, point.y);
		}
	}];

	[NSEvent addGlobalMonitorForEventsMatchingMask:NSEventMaskLeftMouseUp handler:^(NSEvent * event) {
		if ([self isScreen]) return;

		if ([event windowNumber] == [self windowOrScreenNumber]) {
			NSPoint point = [event locationInWindow];

			if ([self debug]) {
				printf("Global leftMouseUp location (x: %f, y: %f)\n", point.x, point.y);
			}

			[self updateFrame];
		}
	}];


	[NSEvent addLocalMonitorForEventsMatchingMask:NSEventMaskLeftMouseDown handler:^NSEvent *(NSEvent * event) {
		if ([self isScreen]) return event;

		if (event != NULL && [event windowNumber] == windowNumber) {
			NSPoint point = [event locationInWindow];

			if ([self debug]) {
				printf("Local leftMouseDown location (x: %f, y: %f)\n", point.x, point.y);
			}
		}
		return event;
	}];

	[NSEvent addLocalMonitorForEventsMatchingMask:NSEventMaskLeftMouseDragged handler:^NSEvent *(NSEvent * event) {
		if ([self isScreen]) return event;

		if (event != NULL && [event windowNumber] == windowNumber) {
				// NSPoint point = [event locationInWindow];
				// printf("Local leftMouseDragged location (x: %f, y: %f)\n", point.x, point.y);
		}
		return event;
	}];

	[NSEvent addLocalMonitorForEventsMatchingMask:NSEventMaskLeftMouseUp handler:^NSEvent *(NSEvent * event) {
		if ([self isScreen]) return event;

		if (event != NULL && [event windowNumber] == windowNumber) {
			NSPoint point = [event locationInWindow];

			if ([self debug]) {
				printf("Local leftMouseUp location (x: %f, y: %f)\n", point.x, point.y);
			}
		}
		return event;
	}];

	id workspaceNotificationHandler = ^(NSNotification * _Nonnull note) {
		if ([self isScreen]) return;

		[NSTimer scheduledTimerWithTimeInterval:TIMER_INTERVAL_SEC repeats:false block:^(NSTimer *timer) {
			NSRunningApplication * application = [[NSWorkspace sharedWorkspace] frontmostApplication];

			if ([application processIdentifier] == [self processId]) {
				if ([self debug]) {
					printf("Calling updateFrame on %s\n", [[note name] UTF8String]);
				}
				[self updateFrame];
			} else if ([self debug]) {
				printf("Skipping updateFrame on %s\n", [[note name] UTF8String]);
			}
		}];
	};

	// Handles case where application is focussed using `Cmd + Tab`
	[[[NSWorkspace sharedWorkspace] notificationCenter]
	 addObserverForName:NSWorkspaceDidActivateApplicationNotification
	 object:nil queue:nil
	 usingBlock:workspaceNotificationHandler];

	// Handles case where user:
	// 1. Switches workspace.
	// 2. Toggles the screen shared app out of immersive full screen
	[[[NSWorkspace sharedWorkspace] notificationCenter]
	 addObserverForName:NSWorkspaceActiveSpaceDidChangeNotification
	 object:NULL queue:NULL
	 usingBlock:workspaceNotificationHandler];

	if ([self debug]) {
		printf("BorderPanelController addGlobalMonitorForEvents end\n");
	}
}

- (BOOL) isScreenNumber:(NSString *) windowOrScreenNumber {
	return [windowOrScreenNumber containsString:@"screen"];
}

- (NSInteger) parseWindowOrScreenNumber:(NSString *) windowOrScreenNumber{
	NSArray<NSString *> * strings = [windowOrScreenNumber componentsSeparatedByString:@":"];

	if ([strings count] == 3) {
		return [strings[1] integerValue];
	}

	return 0;
}

- (NSArray *) getVisibleWindows {
	CFArrayRef windows = CGWindowListCopyWindowInfo(kCGWindowListOptionOnScreenOnly | kCGWindowListExcludeDesktopElements, kCGNullWindowID);
	NSMutableArray * visibleWindows = [[NSMutableArray alloc] init];
	[self setVisibleWindows:visibleWindows];
	CFArrayApplyFunction(windows, CFRangeMake(0, CFArrayGetCount(windows)), &WindowListApplierFunction, (__bridge void *)([self visibleWindows]));

	return visibleWindows;
}

- (NSDictionary *) getWindowByName:(NSString *) windowName {
	NSArray * visibleWindows = [self getVisibleWindows];
	NSDictionary * windowInfo = NULL;
	for (NSUInteger i = 0; i < [visibleWindows count]; i++) {
		windowInfo = [visibleWindows objectAtIndex:i];

		if ([[windowInfo[(id)kCGWindowOwnerName] stringValue] isEqualToString:windowName]) {
			break;
		}
	}
	return windowInfo;
}

- (NSDictionary *) getWindowByNumber:(NSInteger)windowNumber {
	NSArray * visibleWindows = [self getVisibleWindows];
	NSDictionary * windowInfo = NULL;
	for (NSUInteger i = 0; i < [visibleWindows count]; i++) {
		windowInfo = [visibleWindows objectAtIndex:i];

		if ([windowInfo[(id)kCGWindowNumber] intValue] == windowNumber) {
			break;
		}
	}
	return windowInfo;
}

- (pid_t) getWindowProcesssIdFromInfo:(NSDictionary *)windowInfo {
	return (pid_t)[windowInfo[(id)kCGWindowOwnerPID] intValue];
}

- (NSInteger) getWindowNumberFromInfo:(NSDictionary *)windowInfo {
	return [windowInfo[(id)kCGWindowNumber] intValue];
}

- (NSRect) getWindowBoundsFromInfo:(NSDictionary *)windowInfo {
	NSDictionary * bounds = windowInfo[(id)kCGWindowBounds];
	int x = [bounds[@"X"] intValue];
	int y = [bounds[@"Y"] intValue];
	int width = [bounds[@"Width"] intValue];
	int height = [bounds[@"Height"] intValue];

	[self setCurrentX:x];
	[self setCurrentY:y];
	[self setCurrentWidth:width];
	[self setCurrentHeight:height];

	return NSMakeRect(x, y, width, height);
}

void WindowListApplierFunction(const void *inputDictionary, void *context);
void WindowListApplierFunction(const void *inputDictionary, void *context) {
	NSDictionary * entry = (__bridge NSDictionary*)inputDictionary;
	NSMutableArray * data = (__bridge NSMutableArray *)context;

	int windowLaver = [entry[(id)kCGWindowLayer] intValue];

	if (windowLaver == 0) {
		[data addObject:entry];
	}
}

@end
